diff --git a/Configuration.py b/Configuration.py
index 8022334..0e8cfd3 100644
--- a/Configuration.py
+++ b/Configuration.py
@@ -68,8 +68,8 @@ import ignoreDeprecation
 import os
 import sys
 import types
-import regex
 import string
+import re
 
 # if we invoked this module as a script (rather than importing it), then we
 # need to define a usage statement:
@@ -93,43 +93,43 @@ ERR_UNKNOWN_KEYS = 'Uknown configuration options: %s'
 ###--- Regular Expressions for Parsing Configuration Files ---###
 
 # pick out a format specification:
-re_format = regex.compile ('#format: *\(.*\)', regex.casefold)
+re_format = re.compile('#format: *(.*)',re.IGNORECASE)
 
 # pick out comments and blank lines:
-re_comment = regex.compile ('\(#.*\)'		# comment
-			'\|'			# or
-			'\(^[ \t]*$\)')		# blank line
+re_comment = re.compile('(#.*)'			# comment
+			'|'			# or
+			'(^[ \\t]*$)')		# blank line
 
 # parse a tab or space-delimited line:
-re_tabbed = regex.compile ('\([^\t\n ]*\)'	# parameter name
-			'''[\t ]*['"]?'''	# spacing, optional quote
-			'''\([^'"\n]*\)'''	# parameter value
-			'''['"]?''')		# optional quote
+re_tabbed = re.compile('([^\\t\\n ]*)'		# parameter name
+			'[\\t ]*[\'"]?'		# spacing, optional quote
+			'([^\'"\\n]*)'		# parameter value
+			'[\'"]?')		# optional quote
 
 # parse a Bourne shell-formatted line:
-re_shell = regex.compile ('\([^\t =]*\)'	# parameter name
-			'''[\t ]*=[\t ]*'''	# spacing, =, spacing
-			'''['"]?'''		# optional quote
-			'''\([^'"\n]*\)'''	# parameter value
-			'''['"]?''')		# optional quote
+re_shell = re.compile('([^\\t =]*)'		# parameter name
+			'[\\t ]*=[\\t ]*'	# spacing, =, spacing
+			'[\'"]?'		# optional quote
+			'([^\'"\\n]*)'		# parameter value
+			'[\'"]?')		# optional quote
 
 # parse a C-shell-formatted line using 'set':
-re_cshell1 = regex.compile ('set[\t ]+'		# set keyword, spacing
-			'''\([^\t ]*\)'''	# parameter name
-			'''[\t ]*=[\t ]*'''	# spacing, =, spacing
-			'''['"]?'''		# optional quote
-			'''\([^'"\n]*\)'''	# parameter value
-			'''['"]?''')		# optional quote
+re_cshell1 = re.compile('set[\\t ]+'		# set keyword, spacing
+			'([^\\t ]*)'		# parameter name
+			'[\\t ]*=[\\t ]*'	# spacing, =, spacing
+			'[\'"]?'		# optional quote
+			'([^\'"\\n]*)'		# set keyword, spacing
+			'[\'"]?')		# optional quote
 
 # parse a C-shell-formatted line using 'setenv':
-re_cshell2 = regex.compile ('setenv[\t ]+'	# setenv keyword, spacing
-			'''\([^\t\n ]+\)'''	# parameter name
-			'''[\t ]*['"]?'''	# spacing, optional quote
-			'''\([^'"\n]*\)'''	# parameter value
-			'''['"]?''')		# optional quote
+re_cshell2 = re.compile('setenv[\\t ]+'		# setenv keyword, spacing
+			'([^\\t\\n ]+)'		# parameter name
+			'[\\t ]*[\'"]?'		# spacing, optional quote
+			'([^\'"\\n]*)'		# parameter value
+			'[\'"]?')		# optional quote
 
 # find one parameter name embedded within another parameter value:
-re_parm = regex.compile ('\${\([^}]+\)}')	# format like ${MYPARM}
+re_parm = re.compile('\\${([^}]+)}')		# format like ${MYPARM}
 
 ###--- Other Global Variables ---###
 
@@ -314,8 +314,9 @@ class Configuration:
 
 		# check for other formats, as specified in the first line:
 
-		if re_format.match(lines[0]) != -1:
-			format = re_format.group(1)
+		format_match = re_format.match(lines[0])
+		if format_match:
+			format = format_match.group(1)
 			if format == 'tab':		# tab-delimited
 				pass
 			elif format == 'sh':		# Bourne shell
@@ -333,11 +334,12 @@ class Configuration:
 		# blank lines:
 
 		for line in lines:
-			if re_comment.match (line) != -1:
+			if re_comment.match (line):
 				continue
-			for re in regexes:
-				if re.match (line) != -1:
-					field, value = re.group (1,2)
+			for r_e in regexes:
+				re_match = r_e.match(line)
+				if re_match:
+					field, value = re_match.group (1,2)
 					self.options [field] = value
 					break
 
@@ -650,10 +652,12 @@ class Configuration:
 		if steps == 0:
 			raise error, 'Could not resolve parameter.'
 		s = self.options[key]
-		while re_parm.search (s) != -1:
-			start, stop = re_parm.regs[0]
-			parm = re_parm.group(1)
+		re_search_match = re_parm.search(s)
+		while re_search_match:
+			start, stop = re_search_match.span()
+			parm = re_search_match.group(1)
 			s = s[:start] + self.resolve(parm, steps-1) + s[stop:]
+			re_search_match = re_parm.search(s)
 		return s
 
 ###--- Main Program ---###
diff --git a/Profiler.py b/Profiler.py
index 47ad579..1dcda51 100755
--- a/Profiler.py
+++ b/Profiler.py
@@ -11,7 +11,7 @@
 #	output from the Profiler.
 
 import copy
-import regsub
+import re
 import sys
 import time
 import string
@@ -162,7 +162,7 @@ class Profiler:
 			'message'
 			)
 		fp.write(line)
-		fp.write(regsub.gsub ('[^ \n]', '-', line))
+		fp.write(re.sub ('[^ \\n]', '-', line))
 		return
 
 	def __printEntry (self,
diff --git a/glimpselib.py b/glimpselib.py
index 991e6f1..239c347 100644
--- a/glimpselib.py
+++ b/glimpselib.py
@@ -11,7 +11,7 @@
 
 import os
 import string
-import regsub
+import re
 
 SP = ' '
 indexerror = 'indexerror'		# exception raised if problem occurs
@@ -33,7 +33,7 @@ def quote(s):
 	"""
 
 	# Strip all quotes first, then quote the whole search string.
-	s = regsub.gsub('[\'\"]', '', s)
+	s = re.sub('[\'"]', '', s)
 	return '\'' + s + '\''
 
 
@@ -41,12 +41,12 @@ def wais_to_glimpse(query):
 	"""Converts wais query to glimpse query."""
 
 	query = string.lower(query)
-	query = regsub.gsub(' and ', ';', query)
-	query = regsub.gsub(' or ', ',', query)
-	query = regsub.gsub(' not ', '!', query)
-	query = regsub.gsub('*', '#', query)
-	query = regsub.gsub('(', '{', query)
-	query = regsub.gsub(')', '}', query)
+	query = re.sub(' and ', ';', query)
+	query = re.sub(' or ', ',', query)
+	query = re.sub(' not ', '!', query)
+	query = re.sub('*', '#', query)
+	query = re.sub('\\(', '{', query)
+	query = re.sub('\\)', '}', query)
 	return query
 
 
diff --git a/mgi_utils.py b/mgi_utils.py
index 757036c..fda626d 100644
--- a/mgi_utils.py
+++ b/mgi_utils.py
@@ -6,12 +6,12 @@ import string
 import types
 import time
 import ignoreDeprecation
-import regex
 import sys
 import tempfile
 from signal import signal, alarm, SIGALRM
 import runCommand
 from types import *
+import symbolsort
 
 ###--- Exception Information ---###
 error = 'mgi_utils.error'          # standard exception raised by the module
@@ -340,73 +340,9 @@ def date( format = '%c' ):
 	return s
 
 
-def byNumeric( a, b ):
-	"""String comparison that compares numeric substrings separately.
-	#
-	# Requires:
-	#       a, b - strings
-	#
-	# Example:
-	#	Here's how to sort a list of marker symbols:
-	#
-	#		l.sort( mgi_utils.byNumeric )
-	#
-	# Bugs:
-	#	- In some cases, substrings are converted to lower case, which
-	#	  can give random results back (see code).
-	#	- Also, it's kinda slow.  :-)
-	#	- If either of the strings contain numeric substrings that are
-	#	  too big for string.atoi to handle, an exception is raised.
-	#	- Ren1 == ren2
-	#
-	# It's slow because passing any comparison function to the list sort
-	# method slows things to a crawl.
-	#
-	# Note:
-	#	As this is both buggy and slow, code should probably be
-	#	migrated away from using this function.  A better solution is
-	#	in the symbolsort.py library.
-	"""
- 
-        def getIndex( s ): # returns the length of the first chunk.
-                if s[:1] in map( None, string.digits ):
-                        result = regex.search( '[^0-9]', s )
-                else:
-                        result = regex.search( '[0-9]', s )
-		if result < 0: # It's the last chunk in the string.
-			result = len( s )
-		return result
- 
-	if type(a) != types.StringType or type(b) != types.StringType:
-		return cmp(a,b)
-
-        indexA = getIndex( a )
-        indexB = getIndex( b )
-        DIGITS = map( None, string.digits )
- 
-	if a == b: # not necessary, but maybe speeds things up!
-		result = 0
-        elif a[:indexA] == b[:indexB]:
-                if len( a ) == indexA:
-                        if len( b ) == indexB:
-                                result = 0
-                        else:
-                                result = -1
-                elif len( b ) == indexB:
-                        result = 1
-                else:
-                        result = bySymbol( a[indexA:], b[indexB:] )
-        elif a[:1] in DIGITS and b[:1] in DIGITS:
-                result = cmp( string.atoi(a[:indexA]), string.atoi(b[:indexB]) )
-        else:   # This returns can random results (eg. ren1 =? Ren1)
-                # OK if data is already in a reasonable order though.
-                result = cmp(string.lower(a[:indexA]),string.lower(b[:indexB]))
-
-	return result
-
 # aliases
-byFilename = byNumeric
-bySymbol = byNumeric
+byFilename = symbolsort.nomenCompare
+bySymbol = symbolsort.nomenCompare
 
 def setAlarm(timeout, alarmclock=AlarmClock):
 	# Schedule a UNIX alarm call after timeout seconds
diff --git a/rcdlib.py b/rcdlib.py
index 8f8a0bf..78ab384 100644
--- a/rcdlib.py
+++ b/rcdlib.py
@@ -78,15 +78,14 @@
 #				===> Scientific Software Engineer III
 
 import string
-import regex
 import types
+import re
 
 ###--- Global Variables ---###
 
 # regular expression used to find a constant cited in a line as ${...}
 
-variable_re = regex.compile ('\${\([^}]+\)}')
-
+variable_re = re.compile('\\${([^}]+)}')
 ###--- Exception Information ---###
 
 error = 'rcdlib.error'		# exception raised in this module
@@ -638,25 +637,27 @@ def substitute (
 	pos = string.find (s, '$')		# position where we found $
 	if pos == -1:
 		return s
-	pos = variable_re.search (s, pos)	# pos. where we found ${...}
+
+	re_match = variable_re.search(s,pos)	# pos. where we found ${...}
 
 	t = ''			# new string we're building
 	last = 0		# We copied up to this position the last time
 				#	we copied characters into 't'.
-	while pos != -1:
+	while re_match:
+		pos,end = re_match.span()
 
 		# if we found part of a $${name} entry, then just chop off the
 		# first dollar sign and keep the rest of the string
 
 		if s[pos-1] == '$':
-			t = t + s[last:pos-1] + s[pos:variable_re.regs[0][1]]
+			t = t + s[last:pos-1] + s[pos:end]
 
 		# otherwise, add up to the beginning of the ${name}, look up
 		# the value for that constant's name, and add it.
 
 		else:
 			t = t + s[last:pos]
-			name = variable_re.group(1)
+			name = re_match.group(1)
 			if not dict.has_key (name):
 				raise error, BAD_CONSTANT % (name, lineNum)
 			t = t + dict[name]
@@ -664,8 +665,8 @@ def substitute (
 		# remember the last character position matched by the regex
 		# and go look for the next occurrence
 
-		last = variable_re.regs[0][1]
-		pos = variable_re.search (s, last)
+		last = end
+		re_match = variable_re.search (s, last)
 
 	return t + s[last:]
 #
