diff --git a/Configuration.py b/Configuration.py
index 8022334..0e8cfd3 100644
--- a/Configuration.py
+++ b/Configuration.py
@@ -68,8 +68,8 @@ import ignoreDeprecation
 import os
 import sys
 import types
-import regex
 import string
+import re
 
 # if we invoked this module as a script (rather than importing it), then we
 # need to define a usage statement:
@@ -93,43 +93,43 @@ ERR_UNKNOWN_KEYS = 'Uknown configuration options: %s'
 ###--- Regular Expressions for Parsing Configuration Files ---###
 
 # pick out a format specification:
-re_format = regex.compile ('#format: *\(.*\)', regex.casefold)
+re_format = re.compile('#format: *(.*)',re.IGNORECASE)
 
 # pick out comments and blank lines:
-re_comment = regex.compile ('\(#.*\)'		# comment
-			'\|'			# or
-			'\(^[ \t]*$\)')		# blank line
+re_comment = re.compile('(#.*)'			# comment
+			'|'			# or
+			'(^[ \\t]*$)')		# blank line
 
 # parse a tab or space-delimited line:
-re_tabbed = regex.compile ('\([^\t\n ]*\)'	# parameter name
-			'''[\t ]*['"]?'''	# spacing, optional quote
-			'''\([^'"\n]*\)'''	# parameter value
-			'''['"]?''')		# optional quote
+re_tabbed = re.compile('([^\\t\\n ]*)'		# parameter name
+			'[\\t ]*[\'"]?'		# spacing, optional quote
+			'([^\'"\\n]*)'		# parameter value
+			'[\'"]?')		# optional quote
 
 # parse a Bourne shell-formatted line:
-re_shell = regex.compile ('\([^\t =]*\)'	# parameter name
-			'''[\t ]*=[\t ]*'''	# spacing, =, spacing
-			'''['"]?'''		# optional quote
-			'''\([^'"\n]*\)'''	# parameter value
-			'''['"]?''')		# optional quote
+re_shell = re.compile('([^\\t =]*)'		# parameter name
+			'[\\t ]*=[\\t ]*'	# spacing, =, spacing
+			'[\'"]?'		# optional quote
+			'([^\'"\\n]*)'		# parameter value
+			'[\'"]?')		# optional quote
 
 # parse a C-shell-formatted line using 'set':
-re_cshell1 = regex.compile ('set[\t ]+'		# set keyword, spacing
-			'''\([^\t ]*\)'''	# parameter name
-			'''[\t ]*=[\t ]*'''	# spacing, =, spacing
-			'''['"]?'''		# optional quote
-			'''\([^'"\n]*\)'''	# parameter value
-			'''['"]?''')		# optional quote
+re_cshell1 = re.compile('set[\\t ]+'		# set keyword, spacing
+			'([^\\t ]*)'		# parameter name
+			'[\\t ]*=[\\t ]*'	# spacing, =, spacing
+			'[\'"]?'		# optional quote
+			'([^\'"\\n]*)'		# set keyword, spacing
+			'[\'"]?')		# optional quote
 
 # parse a C-shell-formatted line using 'setenv':
-re_cshell2 = regex.compile ('setenv[\t ]+'	# setenv keyword, spacing
-			'''\([^\t\n ]+\)'''	# parameter name
-			'''[\t ]*['"]?'''	# spacing, optional quote
-			'''\([^'"\n]*\)'''	# parameter value
-			'''['"]?''')		# optional quote
+re_cshell2 = re.compile('setenv[\\t ]+'		# setenv keyword, spacing
+			'([^\\t\\n ]+)'		# parameter name
+			'[\\t ]*[\'"]?'		# spacing, optional quote
+			'([^\'"\\n]*)'		# parameter value
+			'[\'"]?')		# optional quote
 
 # find one parameter name embedded within another parameter value:
-re_parm = regex.compile ('\${\([^}]+\)}')	# format like ${MYPARM}
+re_parm = re.compile('\\${([^}]+)}')		# format like ${MYPARM}
 
 ###--- Other Global Variables ---###
 
@@ -314,8 +314,9 @@ class Configuration:
 
 		# check for other formats, as specified in the first line:
 
-		if re_format.match(lines[0]) != -1:
-			format = re_format.group(1)
+		format_match = re_format.match(lines[0])
+		if format_match:
+			format = format_match.group(1)
 			if format == 'tab':		# tab-delimited
 				pass
 			elif format == 'sh':		# Bourne shell
@@ -333,11 +334,12 @@ class Configuration:
 		# blank lines:
 
 		for line in lines:
-			if re_comment.match (line) != -1:
+			if re_comment.match (line):
 				continue
-			for re in regexes:
-				if re.match (line) != -1:
-					field, value = re.group (1,2)
+			for r_e in regexes:
+				re_match = r_e.match(line)
+				if re_match:
+					field, value = re_match.group (1,2)
 					self.options [field] = value
 					break
 
@@ -650,10 +652,12 @@ class Configuration:
 		if steps == 0:
 			raise error, 'Could not resolve parameter.'
 		s = self.options[key]
-		while re_parm.search (s) != -1:
-			start, stop = re_parm.regs[0]
-			parm = re_parm.group(1)
+		re_search_match = re_parm.search(s)
+		while re_search_match:
+			start, stop = re_search_match.span()
+			parm = re_search_match.group(1)
 			s = s[:start] + self.resolve(parm, steps-1) + s[stop:]
+			re_search_match = re_parm.search(s)
 		return s
 
 ###--- Main Program ---###
diff --git a/Profiler.py b/Profiler.py
index 47ad579..1dcda51 100755
--- a/Profiler.py
+++ b/Profiler.py
@@ -11,7 +11,7 @@
 #	output from the Profiler.
 
 import copy
-import regsub
+import re
 import sys
 import time
 import string
@@ -162,7 +162,7 @@ class Profiler:
 			'message'
 			)
 		fp.write(line)
-		fp.write(regsub.gsub ('[^ \n]', '-', line))
+		fp.write(re.sub ('[^ \\n]', '-', line))
 		return
 
 	def __printEntry (self,
diff --git a/glimpselib.py b/glimpselib.py
index 991e6f1..239c347 100644
--- a/glimpselib.py
+++ b/glimpselib.py
@@ -11,7 +11,7 @@
 
 import os
 import string
-import regsub
+import re
 
 SP = ' '
 indexerror = 'indexerror'		# exception raised if problem occurs
@@ -33,7 +33,7 @@ def quote(s):
 	"""
 
 	# Strip all quotes first, then quote the whole search string.
-	s = regsub.gsub('[\'\"]', '', s)
+	s = re.sub('[\'"]', '', s)
 	return '\'' + s + '\''
 
 
@@ -41,12 +41,12 @@ def wais_to_glimpse(query):
 	"""Converts wais query to glimpse query."""
 
 	query = string.lower(query)
-	query = regsub.gsub(' and ', ';', query)
-	query = regsub.gsub(' or ', ',', query)
-	query = regsub.gsub(' not ', '!', query)
-	query = regsub.gsub('*', '#', query)
-	query = regsub.gsub('(', '{', query)
-	query = regsub.gsub(')', '}', query)
+	query = re.sub(' and ', ';', query)
+	query = re.sub(' or ', ',', query)
+	query = re.sub(' not ', '!', query)
+	query = re.sub('*', '#', query)
+	query = re.sub('\\(', '{', query)
+	query = re.sub('\\)', '}', query)
 	return query
 
 
diff --git a/mgi_utils.py b/mgi_utils.py
index 757036c..fda626d 100644
--- a/mgi_utils.py
+++ b/mgi_utils.py
@@ -6,12 +6,12 @@ import string
 import types
 import time
 import ignoreDeprecation
-import regex
 import sys
 import tempfile
 from signal import signal, alarm, SIGALRM
 import runCommand
 from types import *
+import symbolsort
 
 ###--- Exception Information ---###
 error = 'mgi_utils.error'          # standard exception raised by the module
@@ -340,73 +340,9 @@ def date( format = '%c' ):
 	return s
 
 
-def byNumeric( a, b ):
-	"""String comparison that compares numeric substrings separately.
-	#
-	# Requires:
-	#       a, b - strings
-	#
-	# Example:
-	#	Here's how to sort a list of marker symbols:
-	#
-	#		l.sort( mgi_utils.byNumeric )
-	#
-	# Bugs:
-	#	- In some cases, substrings are converted to lower case, which
-	#	  can give random results back (see code).
-	#	- Also, it's kinda slow.  :-)
-	#	- If either of the strings contain numeric substrings that are
-	#	  too big for string.atoi to handle, an exception is raised.
-	#	- Ren1 == ren2
-	#
-	# It's slow because passing any comparison function to the list sort
-	# method slows things to a crawl.
-	#
-	# Note:
-	#	As this is both buggy and slow, code should probably be
-	#	migrated away from using this function.  A better solution is
-	#	in the symbolsort.py library.
-	"""
- 
-        def getIndex( s ): # returns the length of the first chunk.
-                if s[:1] in map( None, string.digits ):
-                        result = regex.search( '[^0-9]', s )
-                else:
-                        result = regex.search( '[0-9]', s )
-		if result < 0: # It's the last chunk in the string.
-			result = len( s )
-		return result
- 
-	if type(a) != types.StringType or type(b) != types.StringType:
-		return cmp(a,b)
-
-        indexA = getIndex( a )
-        indexB = getIndex( b )
-        DIGITS = map( None, string.digits )
- 
-	if a == b: # not necessary, but maybe speeds things up!
-		result = 0
-        elif a[:indexA] == b[:indexB]:
-                if len( a ) == indexA:
-                        if len( b ) == indexB:
-                                result = 0
-                        else:
-                                result = -1
-                elif len( b ) == indexB:
-                        result = 1
-                else:
-                        result = bySymbol( a[indexA:], b[indexB:] )
-        elif a[:1] in DIGITS and b[:1] in DIGITS:
-                result = cmp( string.atoi(a[:indexA]), string.atoi(b[:indexB]) )
-        else:   # This returns can random results (eg. ren1 =? Ren1)
-                # OK if data is already in a reasonable order though.
-                result = cmp(string.lower(a[:indexA]),string.lower(b[:indexB]))
-
-	return result
-
 # aliases
-byFilename = byNumeric
-bySymbol = byNumeric
+byFilename = symbolsort.nomenCompare
+bySymbol = symbolsort.nomenCompare
 
 def setAlarm(timeout, alarmclock=AlarmClock):
 	# Schedule a UNIX alarm call after timeout seconds
diff --git a/rcdlib.py b/rcdlib.py
index 8f8a0bf..78ab384 100644
--- a/rcdlib.py
+++ b/rcdlib.py
@@ -78,15 +78,14 @@
 #				===> Scientific Software Engineer III
 
 import string
-import regex
 import types
+import re
 
 ###--- Global Variables ---###
 
 # regular expression used to find a constant cited in a line as ${...}
 
-variable_re = regex.compile ('\${\([^}]+\)}')
-
+variable_re = re.compile('\\${([^}]+)}')
 ###--- Exception Information ---###
 
 error = 'rcdlib.error'		# exception raised in this module
@@ -638,25 +637,27 @@ def substitute (
 	pos = string.find (s, '$')		# position where we found $
 	if pos == -1:
 		return s
-	pos = variable_re.search (s, pos)	# pos. where we found ${...}
+
+	re_match = variable_re.search(s,pos)	# pos. where we found ${...}
 
 	t = ''			# new string we're building
 	last = 0		# We copied up to this position the last time
 				#	we copied characters into 't'.
-	while pos != -1:
+	while re_match:
+		pos,end = re_match.span()
 
 		# if we found part of a $${name} entry, then just chop off the
 		# first dollar sign and keep the rest of the string
 
 		if s[pos-1] == '$':
-			t = t + s[last:pos-1] + s[pos:variable_re.regs[0][1]]
+			t = t + s[last:pos-1] + s[pos:end]
 
 		# otherwise, add up to the beginning of the ${name}, look up
 		# the value for that constant's name, and add it.
 
 		else:
 			t = t + s[last:pos]
-			name = variable_re.group(1)
+			name = re_match.group(1)
 			if not dict.has_key (name):
 				raise error, BAD_CONSTANT % (name, lineNum)
 			t = t + dict[name]
@@ -664,8 +665,8 @@ def substitute (
 		# remember the last character position matched by the regex
 		# and go look for the next occurrence
 
-		last = variable_re.regs[0][1]
-		pos = variable_re.search (s, last)
+		last = end
+		re_match = variable_re.search (s, last)
 
 	return t + s[last:]
 #
diff --git a/table.py b/table.py
index 7210cf2..e20f4e2 100644
--- a/table.py
+++ b/table.py
@@ -185,11 +185,10 @@ __author__ = 'Glenn T. Colby   gtc@informatics.jax.org'
 
 import types
 import cgi
-import regsub
+import re
 import string
 import os
 import sys
-import regex
 
 
 error = 'myError'
@@ -198,7 +197,7 @@ MISMATCHING_SUBROW = 'Cannot render table with different subrow sizes'
 # Regular Expressions
 # ===================
 
-tag_pattern = regex.compile( '<[^>]*>' )
+tag_pattern = re.compile( '<[^>]*>' )
 
 
 # Functions
@@ -208,7 +207,7 @@ def browser_is_netscape():
 	"""Returns non-zero if browser is Netscape."""
 
 	if os.environ.has_key('HTTP_USER_AGENT'):
-		return regex.match('Mozilla', os.environ['HTTP_USER_AGENT']) + 1
+		return re.match('Mozilla', os.environ['HTTP_USER_AGENT']) + 1
 	else:
 		return 0
 
@@ -221,24 +220,6 @@ def filter_html( s ):
 	return gsub( '<[^>]*>', '', s )
 
 
-def filter_text( s ):
-	"""Recursive function that strips text from a string, leaving HTML tags.
-
-	This is the opposite of filter_html.
-
-	This might be useful if you are trying to do word-wrapping with
-	preformatted text that contains markup.
-	"""
-
-	tag_start =  tag_pattern.search( s )
-	if tag_start != -1:
-		s = s[tag_start:]
-		tag_length = tag_pattern.match( s )
-		return s[:tag_length] + filter_text( s[tag_length:] )
-	else:
-		return ''
-
-
 def escape( s ):
 	"""Replace special characters '&', '<' and '>' by SGML entities."""
 
@@ -278,49 +259,6 @@ def filter_index( i, s ):
 	return len(filter_html(s[:i]))
 
 
-def HTML_index( index, s ):
-	"""Returns the `real' index of a char that has a given filter_index.
-
-	This could be done much more efficiently...
-
-	Used by __wrap() method.
-	"""
-
-	l = []
-	for i in range(len(s)):
-		l.append( s[:i] )
-	l = map( filter_html, l )
-	l = map( len, l )
-	for i in range(len(l)-1, 0, -1):
-		if index == l[i]:
-			break
-	return i
-
-
-def hsplit( s, width ):
-	"""Inserts newlines at appropriate places for preformatted text.
-
-	Used by __wrap method.
-	"""
-
-	f = filter_html(s)
-	if width >= len(f):
-		return s
-	i = width
-	if ' ' in f[:i]:
-		while i:
-			if f[i-1] == ' ':
-				break
-			i = i - 1
-	first_line = s[:HTML_index(i,s)] \
-		+ filter_text(s[HTML_index(i,s):])
-	second_line = hsplit(
-		filter_text(s[:HTML_index(i,s)]) + s[HTML_index(i,s):],
-		width
-		)
-	return first_line + '\n' + second_line
-
-
 def lsort(list, field, html, func = cmp):
 	"""Sorts a list by a field using optional comparison function.
 
@@ -361,7 +299,7 @@ center = string.center
 rjust = string.rjust
 join = string.joinfields
 strip = string.strip
-gsub = regsub.gsub
+gsub = re.sub
 StringType = type('s')
 ListType = type([])
 TupleType = type((0,1))
@@ -624,7 +562,7 @@ class Table:
 			# process cell contents to insert breaks for \n
 			for i in range(len(self.body)):
 				for j in range(len(self.body[i])):
-					self.body[i][j] = gsub('\n', '<br>',
+					self.body[i][j] = gsub('\\n', '<br>',
 						strip(self.body[i][j]))
 
 		# Convert spaces in heading to &nbsp; (Netscape only).
@@ -846,20 +784,6 @@ class Table:
 
 		return s
 
-	def __wrap(self):
-
-		if type(self.cell_width) == IntType:
-			widths = []
-			for i in range(len(self.body[0])):
-				widths.append(self.cell_width)
-			self.cell_width = widths
-
-		for i in range(len(self.body)):
-			for j in range(len(self.body[i])):
-				if self.cell_width[j]:
-					self.body[i][j]=hsplit(self.body[i][j],
-						self.cell_width[j])
-
 
 	def __text(self, pre=0):
 		"""Generates a Table in text format.
@@ -905,15 +829,9 @@ class Table:
 				# determine that we really need to:
 
 				if string.find (self.body[i][j], '\n') != -1:
-					self.body[i][j] = gsub('\n', ' ',	
+					self.body[i][j] = gsub('\\n', ' ',	
 						self.body[i][j])
 
-		#Fix column widths if necessary.
-		#This is commented out because it is too slow.  It ends up
-		#making an *additional* copy of the entire table.
-		#if self.cell_width:
-		#	self.__wrap()
-
 		# Build list of column widths iff padding cells with spaces.
 		if self.pad:
 			self.__widths = [0]*len(self.body[0])
@@ -1070,22 +988,6 @@ class Table:
 				else:
 					break
 
-
-	def read(self, file=sys.stdin):
-		"""Reads a table from a file.
-
-		Not implemented yet.  (Duh...)  This method will probably open
-		a file that contains tab-delimited text and build self.body.
-		Seems useful.
-
-		Perhaps some regex support as well?
-
-		Maybe pass a function as an argument that will process a string
-		and return a list?
-		"""
-		pass
-
-
 	def reverse(self):
 		"""Reverses the rows of the table."""
 		self.__copy.reverse()
